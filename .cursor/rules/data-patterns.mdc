# Data Fetching & Mutation Patterns

This project follows strict architectural patterns for data operations and validation.

## Core Principles

1. **Data Retrieval** ‚Üí Server Components ONLY ‚Üí Using query helpers from `db/queries/`
2. **Data Mutations** (Create/Update/Delete) ‚Üí Server Actions ONLY ‚Üí Using query helpers from `db/queries/`
3. **Database Access** ‚Üí Through helper functions in `db/queries/` directory ONLY
4. **Data Validation** ‚Üí Zod schemas ALWAYS
5. **Type Safety** ‚Üí TypeScript types for all server action parameters (NO FormData type)

## üö® CRITICAL RULE: Database Query Abstraction

**ALL database queries MUST be encapsulated in helper functions within the `db/queries/` directory.**

### ‚ùå FORBIDDEN: Direct Database Queries
```typescript
// ‚ùå DO NOT write database queries directly in components or actions
export default async function DecksPage() {
  const decks = await db
    .select()
    .from(decksTable)
    .where(eq(decksTable.userId, userId)); // ‚ùå WRONG
}
```

### ‚úÖ REQUIRED: Use Query Helpers
```typescript
// ‚úÖ CORRECT - Use query helpers from db/queries/
import { getUserDecks } from '@/db/queries/decks';

export default async function DecksPage() {
  const decks = await getUserDecks(userId); // ‚úÖ CORRECT
}
```

## Installation

If Zod is not installed:
```bash
npm install zod
```

## Query Helper Pattern

### Creating Query Helpers in `db/queries/`

All database queries must be defined as helper functions in the `db/queries/` directory:

```typescript
// db/queries/decks.ts
import { db } from '@/db';
import { decksTable, cardsTable } from '@/db/schema';
import { eq, and, desc } from 'drizzle-orm';

/**
 * Get all decks for a specific user
 */
export async function getUserDecks(userId: string) {
  return await db
    .select()
    .from(decksTable)
    .where(eq(decksTable.userId, userId))
    .orderBy(desc(decksTable.createdAt));
}

/**
 * Get a single deck by ID for a specific user
 */
export async function getUserDeck(userId: string, deckId: number) {
  const [deck] = await db
    .select()
    .from(decksTable)
    .where(
      and(
        eq(decksTable.id, deckId),
        eq(decksTable.userId, userId)
      )
    );
  
  return deck ?? null;
}

/**
 * Get a deck with its cards
 */
export async function getUserDeckWithCards(userId: string, deckId: number) {
  const deck = await getUserDeck(userId, deckId);
  
  if (!deck) {
    return null;
  }
  
  const cards = await db
    .select()
    .from(cardsTable)
    .where(eq(cardsTable.deckId, deckId))
    .orderBy(desc(cardsTable.createdAt));
  
  return { ...deck, cards };
}

/**
 * Create a new deck for a user
 */
export async function createDeck(userId: string, name: string, description?: string) {
  const [newDeck] = await db
    .insert(decksTable)
    .values({
      userId,
      name,
      description,
    })
    .returning();
  
  return newDeck;
}

/**
 * Update a deck (with ownership verification)
 */
export async function updateDeck(
  userId: string,
  deckId: number,
  data: { name: string; description?: string }
) {
  const [updated] = await db
    .update(decksTable)
    .set({
      ...data,
      updatedAt: new Date(),
    })
    .where(
      and(
        eq(decksTable.id, deckId),
        eq(decksTable.userId, userId)
      )
    )
    .returning();
  
  return updated ?? null;
}

/**
 * Delete a deck (with ownership verification)
 */
export async function deleteDeck(userId: string, deckId: number) {
  const [deleted] = await db
    .delete(decksTable)
    .where(
      and(
        eq(decksTable.id, deckId),
        eq(decksTable.userId, userId)
      )
    )
    .returning();
  
  return deleted ?? null;
}
```

## Data Retrieval Pattern

### ‚úÖ CORRECT: Server Components Using Query Helpers

```typescript
import { auth } from '@clerk/nextjs/server';
import { redirect } from 'next/navigation';
import { getUserDecks } from '@/db/queries/decks';

// Server Component - fetches data using query helpers
export default async function DecksPage() {
  const { userId } = await auth();
  
  if (!userId) {
    redirect('/');
  }
  
  // ‚úÖ Use query helper from db/queries/
  const decks = await getUserDecks(userId);
  
  return (
    <div>
      {decks.map(deck => (
        <DeckCard key={deck.id} deck={deck} />
      ))}
    </div>
  );
}
```

### ‚ùå FORBIDDEN: Direct Database Queries in Components

```typescript
import { db } from '@/db';
import { decksTable } from '@/db/schema';
import { eq } from 'drizzle-orm';

// ‚ùå DO NOT write queries directly in components
export default async function DecksPage() {
  const { userId } = await auth();
  
  // ‚ùå FORBIDDEN - Query logic belongs in db/queries/
  const decks = await db
    .select()
    .from(decksTable)
    .where(eq(decksTable.userId, userId));
  
  return <div>...</div>;
}
```

### ‚ùå FORBIDDEN: Client-Side Data Fetching

```typescript
'use client';

import { useEffect, useState } from 'react';

// ‚ùå DO NOT fetch data in client components
export function DecksPage() {
  const [decks, setDecks] = useState([]);
  
  useEffect(() => {
    // ‚ùå DO NOT use useEffect to fetch data
    fetch('/api/decks')
      .then(res => res.json())
      .then(setDecks);
  }, []);
  
  return <div>...</div>;
}
```

```typescript
'use client';

// ‚ùå DO NOT use React Query, SWR, or other client-side data fetching
export function DecksPage() {
  const { data } = useQuery('/api/decks'); // ‚ùå FORBIDDEN
  return <div>...</div>;
}
```

## Data Mutation Pattern

### Zod Schema Definition

Create validation schemas in a dedicated file or co-located with server actions:

```typescript
// lib/validations.ts or actions/deck-actions.ts
import { z } from 'zod';

export const createDeckSchema = z.object({
  name: z.string().min(1, 'Name is required').max(255, 'Name too long'),
  description: z.string().max(1000, 'Description too long').optional(),
});

export const updateDeckSchema = z.object({
  id: z.number().positive(),
  name: z.string().min(1, 'Name is required').max(255, 'Name too long'),
  description: z.string().max(1000, 'Description too long').optional(),
});

export const deleteDeckSchema = z.object({
  id: z.number().positive(),
});

export const createCardSchema = z.object({
  deckId: z.number().positive(),
  front: z.string().min(1, 'Front text is required'),
  back: z.string().min(1, 'Back text is required'),
});

// Export TypeScript types from Zod schemas
export type CreateDeckInput = z.infer<typeof createDeckSchema>;
export type UpdateDeckInput = z.infer<typeof updateDeckSchema>;
export type DeleteDeckInput = z.infer<typeof deleteDeckSchema>;
export type CreateCardInput = z.infer<typeof createCardSchema>;
```

### ‚úÖ CORRECT: Server Actions Using Query Helpers

```typescript
'use server';

import { auth } from '@clerk/nextjs/server';
import { revalidatePath } from 'next/cache';
import { createDeckSchema, type CreateDeckInput } from '@/lib/validations';
import { createDeck as createDeckQuery, updateDeck as updateDeckQuery, deleteDeck as deleteDeckQuery } from '@/db/queries/decks';

// ‚úÖ Typed parameter (not FormData)
export async function createDeckAction(input: CreateDeckInput) {
  // ‚úÖ Validate with Zod
  const validated = createDeckSchema.safeParse(input);
  
  if (!validated.success) {
    return {
      success: false,
      error: validated.error.flatten().fieldErrors,
    };
  }
  
  // ‚úÖ Authenticate
  const { userId } = await auth();
  if (!userId) {
    return { success: false, error: 'Unauthorized' };
  }
  
  try {
    // ‚úÖ Use query helper from db/queries/
    const newDeck = await createDeckQuery(
      userId,
      validated.data.name,
      validated.data.description
    );
    
    // ‚úÖ Revalidate to update UI
    revalidatePath('/decks');
    
    return { success: true, data: newDeck };
  } catch (error) {
    console.error('Create deck error:', error);
    return { success: false, error: 'Failed to create deck' };
  }
}

export async function updateDeckAction(input: UpdateDeckInput) {
  // ‚úÖ Validate
  const validated = updateDeckSchema.safeParse(input);
  if (!validated.success) {
    return {
      success: false,
      error: validated.error.flatten().fieldErrors,
    };
  }
  
  // ‚úÖ Authenticate
  const { userId } = await auth();
  if (!userId) {
    return { success: false, error: 'Unauthorized' };
  }
  
  try {
    // ‚úÖ Use query helper from db/queries/
    const updated = await updateDeckQuery(userId, validated.data.id, {
      name: validated.data.name,
      description: validated.data.description,
    });
    
    if (!updated) {
      return { success: false, error: 'Deck not found or unauthorized' };
    }
    
    revalidatePath('/decks');
    revalidatePath(`/decks/${updated.id}`);
    
    return { success: true, data: updated };
  } catch (error) {
    console.error('Update deck error:', error);
    return { success: false, error: 'Failed to update deck' };
  }
}

export async function deleteDeckAction(input: DeleteDeckInput) {
  // ‚úÖ Validate
  const validated = deleteDeckSchema.safeParse(input);
  if (!validated.success) {
    return { success: false, error: 'Invalid input' };
  }
  
  // ‚úÖ Authenticate
  const { userId } = await auth();
  if (!userId) {
    return { success: false, error: 'Unauthorized' };
  }
  
  try {
    // ‚úÖ Use query helper from db/queries/
    const deleted = await deleteDeckQuery(userId, validated.data.id);
    
    if (!deleted) {
      return { success: false, error: 'Deck not found or unauthorized' };
    }
    
    revalidatePath('/decks');
    
    return { success: true, data: deleted };
  } catch (error) {
    console.error('Delete deck error:', error);
    return { success: false, error: 'Failed to delete deck' };
  }
}
```

### ‚ùå FORBIDDEN: Direct Database Queries in Server Actions

```typescript
'use server';

import { db } from '@/db';
import { decksTable } from '@/db/schema';

// ‚ùå DO NOT write queries directly in server actions
export async function createDeckAction(input: CreateDeckInput) {
  const { userId } = await auth();
  
  // ‚ùå FORBIDDEN - Query logic belongs in db/queries/
  const [newDeck] = await db
    .insert(decksTable)
    .values({
      userId,
      name: input.name,
      description: input.description,
    })
    .returning();
  
  return { success: true, data: newDeck };
}
```

### ‚ùå FORBIDDEN: Anti-Patterns

**Direct Database Queries**
```typescript
// ‚ùå DO NOT write database queries outside of db/queries/
export async function DecksPage() {
  const decks = await db
    .select()
    .from(decksTable)
    .where(eq(decksTable.userId, userId)); // ‚ùå FORBIDDEN
}
```

**Using FormData Type**
```typescript
// ‚ùå DO NOT use FormData as the parameter type
export async function createDeckAction(formData: FormData) {
  const name = formData.get('name');
  // ...
}
```

**No Validation**
```typescript
// ‚ùå DO NOT skip Zod validation
export async function createDeckAction(input: CreateDeckInput) {
  // Missing: const validated = createDeckSchema.safeParse(input);
  
  const deck = await createDeckQuery(userId, input.name); // ‚ùå Using unvalidated input
}
```

**Client-Side Mutations**
```typescript
'use client';

// ‚ùå DO NOT perform mutations in client components
export function CreateDeckForm() {
  const handleSubmit = async () => {
    await db.insert(decksTable).values({...}); // ‚ùå FORBIDDEN
  };
}
```

**API Routes for Mutations**
```typescript
// app/api/decks/route.ts
// ‚ùå DO NOT use API routes for mutations - use Server Actions instead
export async function POST(request: Request) {
  const body = await request.json();
  // ...
}
```

## Client Component Integration

### Using Server Actions in Client Components

```typescript
'use client';

import { useState } from 'react';
import { createDeckAction, type CreateDeckInput } from '@/actions/deck-actions';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';

export function CreateDeckForm() {
  const [name, setName] = useState('');
  const [description, setDescription] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);
    setError(null);
    
    // ‚úÖ Call server action with typed data
    const input: CreateDeckInput = { name, description };
    const result = await createDeckAction(input);
    
    if (result.success) {
      setName('');
      setDescription('');
      // Optionally show success message or redirect
    } else {
      setError(typeof result.error === 'string' ? result.error : 'Failed to create deck');
    }
    
    setIsLoading(false);
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <Input
        value={name}
        onChange={(e) => setName(e.target.value)}
        placeholder="Deck name"
        disabled={isLoading}
      />
      <Input
        value={description}
        onChange={(e) => setDescription(e.target.value)}
        placeholder="Description (optional)"
        disabled={isLoading}
      />
      {error && <p className="text-destructive">{error}</p>}
      <Button type="submit" disabled={isLoading}>
        {isLoading ? 'Creating...' : 'Create Deck'}
      </Button>
    </form>
  );
}
```

### Using useTransition for Optimistic Updates

```typescript
'use client';

import { useTransition } from 'react';
import { deleteDeckAction } from '@/actions/deck-actions';
import { Button } from '@/components/ui/button';

export function DeleteDeckButton({ deckId }: { deckId: number }) {
  const [isPending, startTransition] = useTransition();
  
  const handleDelete = () => {
    if (!confirm('Are you sure?')) return;
    
    startTransition(async () => {
      const result = await deleteDeckAction({ id: deckId });
      if (!result.success) {
        alert(result.error);
      }
    });
  };
  
  return (
    <Button
      variant="destructive"
      onClick={handleDelete}
      disabled={isPending}
    >
      {isPending ? 'Deleting...' : 'Delete'}
    </Button>
  );
}
```

## Validation Patterns

### Complex Validation

```typescript
import { z } from 'zod';

// Custom refinements
export const createCardSchema = z.object({
  deckId: z.number().positive(),
  front: z.string()
    .min(1, 'Front text is required')
    .max(1000, 'Front text too long'),
  back: z.string()
    .min(1, 'Back text is required')
    .max(1000, 'Back text too long'),
}).refine(
  (data) => data.front !== data.back,
  { message: 'Front and back cannot be identical', path: ['back'] }
);

// Optional fields with defaults
export const updateUserPreferencesSchema = z.object({
  cardsPerSession: z.number().int().min(1).max(100).default(10),
  showHints: z.boolean().default(true),
  theme: z.enum(['light', 'dark', 'system']).default('system'),
});

// Nested objects
export const bulkCreateCardsSchema = z.object({
  deckId: z.number().positive(),
  cards: z.array(
    z.object({
      front: z.string().min(1),
      back: z.string().min(1),
    })
  ).min(1, 'At least one card is required'),
});
```

### Handling Validation Errors in UI

```typescript
'use client';

import { useState } from 'react';
import { createCardAction, type CreateCardInput } from '@/actions/card-actions';
import { ZodError } from 'zod';

type FieldErrors = {
  [K in keyof CreateCardInput]?: string[];
};

export function CreateCardForm({ deckId }: { deckId: number }) {
  const [front, setFront] = useState('');
  const [back, setBack] = useState('');
  const [fieldErrors, setFieldErrors] = useState<FieldErrors>({});
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setFieldErrors({});
    
    const result = await createCardAction({ deckId, front, back });
    
    if (!result.success) {
      if (typeof result.error === 'object') {
        // Zod field errors
        setFieldErrors(result.error as FieldErrors);
      }
    } else {
      setFront('');
      setBack('');
    }
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <div>
        <Input value={front} onChange={(e) => setFront(e.target.value)} />
        {fieldErrors.front && (
          <p className="text-destructive text-sm">{fieldErrors.front[0]}</p>
        )}
      </div>
      <div>
        <Input value={back} onChange={(e) => setBack(e.target.value)} />
        {fieldErrors.back && (
          <p className="text-destructive text-sm">{fieldErrors.back[0]}</p>
        )}
      </div>
      <Button type="submit">Create Card</Button>
    </form>
  );
}
```

## File Structure

Recommended organization:

```
app/
  decks/
    page.tsx              # ‚úÖ Server Component - calls query helpers
    [id]/
      page.tsx            # ‚úÖ Server Component - calls query helpers
actions/
  deck-actions.ts         # ‚úÖ Server Actions - calls query helpers
  card-actions.ts         # ‚úÖ Server Actions - calls query helpers
db/
  queries/
    decks.ts              # ‚úÖ Database query helpers for decks
    cards.ts              # ‚úÖ Database query helpers for cards
    users.ts              # ‚úÖ Database query helpers for users
  index.ts                # Database client instance
  schema.ts               # Database schema definitions
lib/
  validations.ts          # Zod schemas and types
components/
  create-deck-form.tsx    # Client Component using server actions
  deck-card.tsx           # Client or Server Component (presentational)
```

**Directory Purposes:**
- `app/` - UI pages (Server Components that call query helpers)
- `actions/` - Server Actions that validate input and call query helpers
- `db/queries/` - **ALL database queries** (the only place where `db.select()`, `db.insert()`, etc. appear)
- `lib/` - Validation schemas and shared utilities
- `components/` - Presentational components

## Best Practices

1. **Query abstraction**: ALL database queries must be in `db/queries/` directory - NEVER write queries directly in components or actions

2. **Query helper naming**: Use descriptive names like `getUserDecks`, `createDeck`, `updateDeck`, `deleteDeck`

3. **Always validate**: Every server action must validate input with Zod before processing

4. **Type everything**: Use `z.infer<typeof schema>` to generate TypeScript types from Zod schemas

5. **Return consistent shapes**: Server actions should return `{ success: boolean, data?: T, error?: E }`

6. **Revalidate paths**: After mutations, use `revalidatePath()` to update the UI

7. **Handle errors gracefully**: Use `safeParse()` instead of `parse()` to avoid throwing errors

8. **Co-locate schemas**: Keep Zod schemas near the server actions that use them

9. **Avoid FormData**: Always use typed objects for server action parameters

10. **No client-side mutations**: Database operations only in server components/actions via query helpers

11. **Authentication in queries**: Query helpers should accept `userId` as a parameter

12. **Ownership in queries**: Query helpers should include ownership verification in WHERE clauses

13. **Reusable queries**: Design query helpers to be reusable across multiple actions/components

14. **Document queries**: Add JSDoc comments to query helpers explaining their purpose

## Revalidation Strategies

```typescript
import { revalidatePath, revalidateTag } from 'next/cache';

// Revalidate specific path
revalidatePath('/decks');

// Revalidate dynamic segment
revalidatePath(`/decks/${deckId}`);

// Revalidate all decks pages
revalidatePath('/decks', 'layout');

// Tag-based revalidation (advanced)
// In fetch: fetch(url, { next: { tags: ['decks'] } })
revalidateTag('decks');
```

## Summary

| Operation | Method | UI Layer | Business Logic | Database Layer |
|-----------|--------|----------|----------------|----------------|
| **Read** | Direct call | Server Component | N/A | Query helper in `db/queries/` |
| **Create** | Server Action | Client Component | Validate (Zod) + Auth | Query helper in `db/queries/` |
| **Update** | Server Action | Client Component | Validate (Zod) + Auth | Query helper in `db/queries/` |
| **Delete** | Server Action | Client Component | Validate (Zod) + Auth | Query helper in `db/queries/` |

**Remember:**
- üìñ Reads = Server Components ‚Üí Query Helpers
- ‚úèÔ∏è Writes = Server Actions ‚Üí Query Helpers
- üóÑÔ∏è Database = Query Helpers in `db/queries/` ONLY
- ‚úÖ Always = Zod Validation
- üîí Always = Authentication & Authorization
- üö´ Never = FormData types or client-side DB access
- üö´ Never = Direct database queries outside `db/queries/`

**Data Flow:**
```
Component/Action ‚Üí Query Helper ‚Üí Database
     (UI)       ‚Üí (db/queries/)  ‚Üí (Drizzle ORM)
```
